// Don't require these until we've hooked certain builtins

const NODE_VERSION = process.version.slice(1).split('.').map((v) => parseInt(v, 10));

const log = (level, msg) => {
  process.stdout.write(`${level} - ${msg}\n`);
};

module.exports.cleanup = () => {
  // sort the active handles into different types for logging
  const sockets = [];
  const fds = [];
  const servers = [];
  const _timers = [];
  const processes = [];
  const clusterWorkers = [];
  const other = [];
  /* eslint-disable global-require */
  const path = require('path');
  const dgramSocket = require('dgram').Socket;
  const HttpServer = require('http').Server;
  const HttpsServer = require('https').Server;
  const { Server } = require('net');
  const { Socket } = require('net');
  const TlsServer = require('tls').Server;
  const { ChildProcess } = require('child_process');
  const cluster = require('cluster');
  const { Timer } = process.binding('timer_wrap');
  const async_hooks = require('async_hooks');
  /* eslint-enable global-require */

  process._getActiveHandles().forEach((h) => {
    // var child_process;

    // handles can be null now? early exit to guard against this
    if (!h) { return; }

    if (h instanceof Socket) {
      // stdin, stdout, etc. are now instances of socket and get listed in open handles
      // todo: a more specific/better way to identify them than the 'fd' property
      if ((h.fd != null)) { fds.push(h); } else { sockets.push(h); }
    } else if (h instanceof Server) {
      servers.push(h);
    } else if (h instanceof dgramSocket) {
      servers.push(h);
    } else if (NODE_VERSION[0] < 11 && h instanceof Timer) {
      _timers.push(h);
    } else if (h instanceof ChildProcess) {
      processes.push(h);
    // eslint-disable-next-line no-prototype-builtins
    } else if (h.hasOwnProperty('__worker')) {
      clusterWorkers.push(h);
    } else { other.push(h); }
  });

  if (fds.length) {
    fds.forEach((s) => {
      let str = `  - fd ${s.fd}`;
      if (s.isTTY) { str += ' (tty)'; }
      if (s._isStdio) { str += ' (stdio)'; }
      if (s.destroyed) { str += ' (destroyed)'; }
      log('info', str);

      // this event will source the origin of a readline instance, kind of indirectly
      const keypressListeners = s.listeners('keypress');
      if (keypressListeners && keypressListeners.length) {
        log('info', '    - Listeners:');
        keypressListeners.forEach((fn) => {
          const callSite = getCallsite(fn);
          log('info', '      - %s: %s @ %s:%d', 'keypress', fn.name || fn.__name || callSite.name || '(anonymous)', callSite.file, callSite.line);
        });
      }
    });
  }

  // remove cluster workers from child process list
  clusterWorkers.forEach((p) => {
    if (!p.__worker || !p.__worker.process) { return; }
    const cw = p.__worker.process;
    const idx = processes.indexOf(cw);

    if (idx > -1) { processes.splice(idx, 1); }
  });

  if (processes.length) {
    log('info', '- Child processes');
    processes.forEach((cp) => {
      const fds = [];
      log('info', '  - PID %s', cp.pid);
      if (!DONT_INSTRUMENT.ChildProcess) {
        const callSite = getCallsite(cp);
        log('info', '    - Entry point: %s:%d', callSite.file, callSite.line);
      }
      if (cp.stdio && cp.stdio.length) {
        cp.stdio.forEach((s) => {
          if (s && s._handle && (s._handle.fd != null)) { fds.push(s._handle.fd); }
          const idx = sockets.indexOf(s);
          if (idx > -1) {
            sockets.splice(idx, 1);
          }
        });
        if (fds && fds.length) {
          log('info', '    - STDIO file descriptors:', fds.join(', '));
        }
      }
    });
  }

  if (clusterWorkers.length) {
    log('info', '- Cluster workers');
    clusterWorkers.forEach((cw) => {
      const fds = []; const
        cp = cw.__worker.process;
      log('info', '  - PID %s', cp.pid);
      const callSite = getCallsite(cw);
      log('info', '    - Entry point: %s:%d', callSite.file, callSite.line);
    });
  }

  if (sockets.length) {
    log('info', '- Sockets:');
    sockets.forEach((s) => {
      if (s.destroyed) {
        log('info', '  - (?:?) -> %s:? (destroyed)', s._host);
      } else if (s.localAddress) {
        log('info', '  - %s:%s -> %s:%s', s.localAddress, s.localPort, s.remoteAddress, s.remotePort);
      } else if (s._handle && (s._handle.fd != null)) {
        log('info', '  - fd %s', s._handle.fd);
      } else {
        log('info', '  - unknown socket');
      }
      const connectListeners = s.listeners('connect');
      if (connectListeners && connectListeners.length) {
        log('info', '    - Listeners:');
        connectListeners.forEach((fn) => {
          const callSite = getCallsite(fn);
          log('info', '      - %s: %s @ %s:%d', 'connect', fn.name || fn.__name || callSite.name || '(anonymous)', callSite.file, callSite.line);
        });
      }
    });
  }

  if (servers.length) {
    log('info', '- Servers:');
    servers.forEach((s) => {
      let type = 'unknown type';
      if (s instanceof HttpServer) { type = 'HTTP'; } else if (s instanceof HttpsServer) { type = 'HTTPS'; } else if (s instanceof TlsServer) { type = 'TLS'; } else if (s instanceof Server) { type = 'TCP'; } else if (s instanceof dgramSocket) { type = 'UDP'; }

      try {
        var a = s.address();
      } catch (e) {
        if (type === 'UDP') {
          // udp sockets that haven't been bound will throw, but won't prevent exit
          return;
        }
        throw e;
      }

      if (a) {
        log('info', '  - %s:%s (%s)', a.address, a.port, type);
      } else {
        log('info', '  - <unknown address>'); // closed / race condition?
      }

      const eventType = (
        type === 'HTTP' || type === 'HTTPS' ? 'request'
          : type === 'TCP' || type === 'TLS' ? 'connection'
            : type === 'UDP' ? 'message'
              : 'connection'
      );

      const listeners = s.listeners(eventType);

      if (listeners && listeners.length) {
        log('info', '    - Listeners:');
        listeners.forEach((fn) => {
          const callSite = getCallsite(fn);
          log('info', '      - %s: %s @ %s:%d', eventType, fn.name || fn.__name || callSite.name || '(anonymous)', callSite.file, callSite.line);
        });
      }
    });
  }

  const timers = []; const
    intervals = [];
  _timers.forEach((t) => {
    let timer = t._list; let cb; let
      cbkey;
    if (NODE_VERSION[0] > 10) {
      timer = t;
      cbkey = timerCallback(timer);
      if (cbkey && timers.indexOf(timer) === -1) {
        cb = timer[cbkey];
        if (cb.__isInterval) {
          intervals.push(timer);
        } else {
          timers.push(timer);
        }
      }
    } else if (t._list) {
      // node v5ish behavior
      do {
        cbkey = timerCallback(timer);
        if (cbkey && timers.indexOf(timer) === -1) {
          cb = timer[cbkey];
          if (cb.__isInterval || cbkey === '_repeat') {
            intervals.push(timer);
          } else {
            timers.push(timer);
          }
        }
        timer = timer._idleNext;
      } while (!timer.constructor || timer !== t._list);
    } else {
      // node 0.12ish behavior
      _timers.forEach((t) => {
        let timer = t;
        while ((timer = timer._idleNext)) {
          if (timer === t) {
            break;
          }
          cbkey = timerCallback(timer);
          if (cbkey && timers.indexOf(timer) === -1) {
            cb = timer[cbkey];
            if (cb.__isInterval) {
              intervals.push(timer);
            } else {
              timers.push(timer);
            }
          }
        }
      });
    }
  });

  if (timers.length) {
    log('info', '- Timers:');

    timers.forEach((t) => {
      const fn = t[timerCallback(t)];
      const callSite = getCallsite(fn);

      log('info', '  - (%d ~ %s) %s @ %s:%d', t._idleTimeout, formatTime(t._idleTimeout), fn.name || fn.__name || callSite.name || '(anonymous)', callSite.file, callSite.line);
    });
  }

  if (intervals.length) {
    log('info', '- Intervals:');

    intervals.forEach((t) => {
      const fn = t[timerCallback(t)];
      const callSite = getCallsite(fn);

      log('info', '  - (%d ~ %s) %s @ %s:%d', t._idleTimeout, formatTime(t._idleTimeout), fn.name || fn.__name || callSite.name, callSite.file, callSite.line);
    });
  }

  if (other.length) {
    log('info', '- Others:');
    other.forEach((o) => {
      if (!o) { return; }
      if (isChannel(o)) {
        log('info', '  - %s', 'IPC channel to parent (see readme)');
      } else if (o.constructor) { log('info', '  - %s', o.constructor.name); } else { log('info', '  - %s', o); }
    });
  }
};
